//------------------------------------------------
//      File: Wildstar_Area.bt
//   Authors: Zee
//   Version: 1.0
//   Purpose: Reading the wildstar area map chunk
//  Category: Wildstar
//------------------------------------------------

#include "Lib/Common.bt"

struct Header
{
    CHUNKID chunkID;
    uint version;
};

struct HeightMap
{
    ushort map[19 * 19];
};

struct TextureIDs
{
    uint IDs[4];
};

struct BlendMap
{
    ushort data[65 * 65];
};

struct ColorMap
{
    ushort data[65 * 65];
};

struct UnkMap
{
    uint data[65 * 65];
};

struct ShadowMap
{
    // 4225 bytes
    byte data[65 * 65];
};

struct LoDHeightMap
{
    ushort data[33 * 33];
};

struct LoDHeightRange
{
    ushort min;
    ushort max;
};

struct ColorMapDXT
{
    // DXT5 65x65 texture, no mips, clamp
    byte data[4624];
};

struct ZoneBounds
{
    byte data[64 * 64];
};

struct BlendMapDXT
{
    // DXT1 65x65 texture, no mips, clamp
    byte data[2312];
};

struct UnkMapDXT
{
    // DXT1 65x65 texture, no mips, clamp
    byte data[2312];
};

struct ZoneIDs
{
    uint ids[4];
};

struct CornerWeights
{
    unsigned byte skyLayerWeights[4];
};

struct EnvironmentWeights
{
    CornerWeights corners[4];
};

struct CornerData
{
    // Game can blend between 4 different skyes to make a more unique one
    uint worldSkyIDs[4];    // IDs into WorldSky.tbl   
};

struct EnvironmentData
{
    // It's blended between the 4 corners of the subchunk based on the player position (not camera)
    CornerData corners[4];
};

typedef struct {
    uint hasHeightmap : 1 <name = "Heightmap">;
    uint hasTextureIDs : 1 <name = "Texture IDs">;
    uint hasBlendMapRaw : 1 <name = "Blend Map Raw">;
    uint hasColorMapRaw : 1 <name = "Color Map Raw">;
    uint unkMap : 1 <name = "Unk Map Raw">;
    uint unk1 : 1 <name = "unk1">;
    uint hasEnvironmentData : 1 <name = "Environment Data">;
    uint hasEnvironmentWeights : 1 <name = "Environment Weights">;
    uint hasShadowMap : 1 <name = "Shadow Map">;
    uint hasLoDHeightMap : 1 <name = "LoD Height Map">;
    uint hasLoDHeightRange : 1 <name = "LoD Height Range">;
    uint unk6 : 1 <name = "unk6">;
    uint unk7 : 1 <name = "unk7">;
    uint hasColorMapDXT : 1 <name = "Color Map DXT">;
    uint unkMap0 : 1 <name = "Unk Map 0 DXT">;
    uint unk9 : 1 <name = "unk9">;
    uint hasZoneBounds : 1 <name = "World Zone Bounds">;
    uint hasBlendMapDXT : 1 <name = "Blend Map DXT">;
    uint hasUnkMap1 : 1 <name = "Unk Map 1 DXT">;
    uint hasUnkMap2 : 1 <name = "Unk Map 2 DXT">;
    uint hasUnkMap3 : 1 <name = "Unk Map 3 DXT">;
    uint hasFlags : 1 <name = "Flags">;
    uint unk15 : 1 <name = "unk15">;
    uint unk16 : 1 <name = "unk16">;
    uint unk17 : 1 <name = "unk17">;
    uint unk18 : 1 <name = "unk18">;
    uint unk19 : 1 <name = "unk19">;
    uint unk20 : 1 <name = "unk20">;
    uint hasZoneIDs : 1 <name = "World Zone IDs">;
    uint unk22 : 1 <name = "unk22">;
    uint unk23 : 1 <name = "unk23">;
    uint hasUnkMap4 : 1 <name = "Unk Map 4 DXT">;
} SubchunkFlags <name = "SubchunkFlags", size = 4>;

struct SUBCHUNK
{
    uint size;
    if (size > FileSize())  // This needs a better interpretation, sometimes the chunk size is a short sometimes an int
    {
        FSkip(-4);
        ushort size;
        ushort unk;
    }

    local long save = FTell();
    SubchunkFlags flags;
    
    if(flags.hasHeightmap)
        HeightMap heightMap;
    if(flags.hasTextureIDs)
        TextureIDs textureIDs;
    if(flags.hasBlendMapRaw)
        BlendMap blendMap;
    if(flags.hasColorMapRaw)
        ColorMap colorMap;
    if(flags.unkMap)
        UnkMap unkMap;
    if(flags.unk1)
        byte unks1[4];
    if(flags.hasEnvironmentData)
        EnvironmentData envLayers;
    if(flags.hasEnvironmentWeights)
        EnvironmentWeights envWeights;
    if(flags.hasShadowMap)
        ShadowMap shadowMap;
    if(flags.hasLoDHeightMap)
        LoDHeightMap heightMap;
    if(flags.hasLoDHeightRange)
        LoDHeightRange heightRange;
    if(flags.unk6)
        byte unks6[578];
    if(flags.unk7)
        byte unk7;
    if(flags.hasColorMapDXT)
        ColorMapDXT colorMap;
    if(flags.unkMap0)
        UnkMapDXT unkMap0;
    if(flags.unk9)
        byte unks9[8450];
    if(flags.hasZoneBounds)
        ZoneBounds zoneBounds;
    if(flags.hasBlendMapDXT)
        BlendMapDXT blendMap;
    if(flags.hasUnkMap1)
        UnkMapDXT unkMap1;
    if(flags.hasUnkMap2)
        UnkMapDXT unkMap2;
    if(flags.hasUnkMap3)
        UnkMapDXT unkMap3;
    if(flags.hasFlags)
        unsigned byte chunkFlags;     // 0x1 = isUnderwater
    if(flags.unk15)
        int unks15[4];
    if(flags.unk16)
        byte unks16[16900];
    if(flags.unk17)
        byte unks17[8];
    if(flags.unk18)
        byte unks18[8450];
    if(flags.unk19)
        byte unks19[21316];
    if(flags.unk20)
        byte unks20[4096];
    if(flags.hasZoneIDs)
        ZoneIDs zoneIDs;            // MapZoneHex.tbl ??
    if(flags.unk22)
        byte unks22[8450];
    if(flags.unk23)
        byte unks23[8450];
    if(flags.hasUnkMap4)
        UnkMapDXT unkMap4;
};

struct PROP
{
    CHUNK chunk;
    uint entries[chunk.size / 4];
};

struct CurdGroup
{
    uint positionCount;
    VECTOR3 positions[positionCount]<optimize=false>;
};

struct curD
{
    CHUNK chunk;
    local long save = FTell();
    uint groupCount;
    CurdGroup groups[groupCount]<optimize=false>;
};

struct WaterVertex
{
    VECTOR3 position;
    VECTOR3 normal;
    VECTOR3 tangent;
    VECTOR3 bitangent;
    VECTOR2 uv;
    RGBA32 color;
    float unk;
    uint unk;
    RGBA32 layerBlendMask;
};

struct Water
{
    uint worldWaterTypeID;          // Entry in WorldWaterType tbl
    uint waterLayerIDs[4];          // Entries in WorldWaterLayer tbl, they get blended together (vertex layer blend mask)
    uint unk0;
    float unk1;
    uint unk2;
    float unk3;
    float unk4;
    uint unk5;
    uint unk6;
    float shoreLineDistance;
    float unk7;
    uint shoreLineWaterLayerID;     // Entry in WorldWaterLayer tbl
    uint unk8;
    uint indexCount;
    uint vertexCount;
    uint unk9;
    uint unk10;
    uint indices[indexCount];
    WaterVertex vertices[vertexCount]<optimize=false>;
};

struct WAtG
{
    CHUNK chunk;
    local long save = FTell();
    uint count;
    Water waters[count]<optimize=false>;

    FSeek(save + chunk.size);
};

struct Leaf
{
    VECTOR2 min;
    VECTOR2 max;
    uint id;
    uint unk;
};

struct Node
{
    Leaf leafs[4];

    // Next stuff needs work
    uint unks[4];
    int unks2[2];
    VECTOR2 min;
    VECTOR2 max;
    uint unks3[14];
};

struct BSP
{
    uint unk0;
    uint unk1;
    uint unk2;
    uint unk3;
    uint unk4;
    uint unk5;
    float unkf;
    uint unk;
    float unkf;
    float unkf;
    uint unk;
    uint unk;
    float unkf;
    float unkf;
    uint unk;
    uint unk;
    uint countA;
    uint countB;
    uint unk;
    uint unk;
    Node nodes[countA];
};

struct wbsP
{
    CHUNK chunk;
    local long save = FTell();
    uint count;
    BSP bsp;
    //BSP bsps[count]<optimize=false>;

    FSeek(save + chunk.size);
};

struct CHNK
{
    CHUNK chunk;
    local long save = FTell();
    while(FTell() < save + chunk.size)
    {
        SUBCHUNK subChunk;
        while (FTell() < subChunk.save + subChunk.size - 1)
        {
            // Extra chunks
            if     ( match( "PROP" ) ) PROP props;
            else if( match( "curD" ) ) curD curds;  // https://cdn.discordapp.com/attachments/487618232279105540/924871987392823327/unknown.png
            else if( match( "WAtG" ) ) WAtG water;
            else if( match( "wbsP" ) ) wbsP bsp;
            else SKIPCHUNKR unk; 
        }
    }
};

enum<uint> MODELTYPE {
    M3 = 0,
    I3 = 1,
    Unk0 = 2,
    DGN = 3,
    Unk1 = 4,
};

typedef struct (int end)
{
    uint32 UUID;        // used in PROP chunks as references for collision/etc.
    uint32 ParentID;
    uint32 unk0;
    uint32 unk1;
    MODELTYPE modelType;
    int pathOffset;
    int unkOffset0;
    float scale;
    QUATERNION rotation;
    VECTOR3 position;
    byte unk3;
    byte unk4;
    byte unk5;
    byte unk6;
    byte unk7;
    byte unk8;
    byte unk9;
    byte unk10;
    int unk11;
    int unk12;           // 0's
    int unk13;
    RGBA32 color0;      // typically 7f7f7fff so just a multiplier shading color
    RGBA32 color1;
    int unk14;
    int unk15;
    RGBA32 color2;
    int unk16;          // 0's

    local int save = FTell();
    if (pathOffset != 0)
    {
        FSeek(end + pathOffset);
        wstring filePath;
        FSeek(save);
    }
    if (unkOffset0 != 0)
    {
        FSeek(end + unkOffset0);
        int unks[4];
        FSeek(save);
    }
}PropInfo<read=readPropInfo>;

string readPropInfo(PropInfo &i)
{
    if (i.pathOffset == 0)
        return "[No File Path]";
    return i.filePath;
}

struct PROp
{
    CHUNK chunk;
    local long save = FTell();
    int propCount;
    PropInfo props(save)[propCount]<optimize=false>;

    // Skip to end of chunk
    FSeek(save + chunk.size);
};

typedef struct (int end)
{
    int unk0;
    short positionCount;
    short unk1;
    short unk2;
    short unk3;
    short unk4;
    short unk5;
    int positionOffset;
    int unk6;

    local int save = FTell();
    FSeek(end + positionOffset);
    VECTOR3 positions[positionCount];
    FSeek(save);
}CurtInfo;

struct CURT
{
    CHUNK chunk;
    local long save = FTell();

    int count;
    CurtInfo infos(save)[count]<optimize=false>;

    // Skip to end of chunk
    FSeek(save + chunk.size);
};

Header header;
while( ! FEof() )
{
    if     ( match( "CHNK" ) ) CHNK chnk;
    else if( match( "PROp" ) ) PROp props;
    else if( match( "CURT" ) ) CURT curt;
    else SKIPCHUNKR unk; 
}