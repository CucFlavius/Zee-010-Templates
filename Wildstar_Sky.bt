//------------------------------------------------
//      File: Wildstar_Sky.bt
//   Authors: Zee
//   Version: 1.0
//   Purpose: Reading the wildstar sky definition file
//  Category: Wildstar
//------------------------------------------------

#include "Lib/Common.bt"
local int dOfs = 1216;  // Data Offset
if(ThemeIsDark()) ThemeAutoScaleColors (true, 0.99);

typedef struct(int len)
{
    local int padLen = 16 - ((len * 2) % 16);
    if (len == 1)
        byte padding[15];
    else
        byte padding[padLen]<optimize=false>;
}PAD<hidden=true>;

void PAD16()
{
    local int padLen = (FTell() % 16);
    FSkip(padLen);  
}

struct sub_1407D0F30
{
    int64 unkOne;         // Always 1
    M3ARRAY colorBlockArray;       // ptr + 8
    M3ARRAY unk1;       // ptr + 24
    M3ARRAY unk2;       // ptr + 40
    M3ARRAY unk3;       // ptr + 56
    M3ARRAY unk4;       // ptr + 72
    M3ARRAY unk7;       // ptr + 88
    M3DOUBLEARRAY unk5; // ptr + 104
    M3DOUBLEARRAY skySphereGradient; // ptr + 128
};

struct ColorBlock(M3DOUBLEARRAY &array, int offs)
{
    FSeek(offs + array.offsetA);
    int timeOfDay[array.elements];
    FSeek(offs + array.offsetB);
    RGBA color[array.elements]<optimize=false>;
};

struct FogSettings
{
    float unk0;
    float fogStartDistance;
    float unk1;
    float unk2;
    float unk3;
    float unk4;
};

struct FogBlock(M3DOUBLEARRAY &array, int offs)
{
    FSeek(offs + array.offsetA);
    int timeOfDay[array.elements];
    FSeek(offs + array.offsetB);
    FogSettings settings[array.elements]<optimize=false>;
};

struct AngleAndColor
{
    float unkFloats[4];
    RGBA color<bgcolor=cYellow>;
};

struct AngleAndColorBlock(M3DOUBLEARRAY &array, int offs)
{
    FSeek(offs + array.offsetA);
    int timeOfDay[array.elements];       // Rotation
    FSeek(offs + array.offsetB);
    AngleAndColor colorUnk[array.elements]<optimize=false>;
};

struct Gradient2
{
    float unkFloats[4];
    RGBA colorA<bgcolor=cYellow>;
    RGBA colorB<bgcolor=cYellow>;
};

struct Gradient2Block(M3DOUBLEARRAY &array, int offs)
{
    FSeek(offs + array.offsetA);
    int timeOfDay[array.elements];
    FSeek(offs + array.offsetB);
    Gradient2 gradient[array.elements]<optimize=false>;
};

struct UnkColorSubBlock3
{
    float unkFloats0[4];
    RGBA colorA;
    float unkFloats1[4];
};

struct UnkColorBlock3(M3DOUBLEARRAY &array, int offs)
{
    FSeek(offs + array.offsetA);
    int timeOfDay[array.elements];
    FSeek(offs + array.offsetB);
    UnkColorSubBlock3 colorUnk[array.elements]<optimize=false>;
};

struct Gradient16
{
    byte padding[16];
    RGBA colors[16]<optimize=false>;;
};

struct PostFXSettings
{
    RGBA overlayColor;
    byte padding0[8];
    float finalImageSaturation;         // 0-1; default 1
    float inverseColorOverlay;          // 0-1; 1 = no overlay, 0 = full overlay; default 1
    float brightness;                   // 0-X; default 1; (or gamma)
    float inverseExposure;              // 0-X; default 1; doesn't affect emissives/specular
    byte padding1[20];
    float inverseGamma;                 // Probably, default 0.109375, can go below 0
    float bloomAlpha;                   // Overall bloom contribution
    float bloomStrength;
    float unk2;                         // 1.0
    float unk3;                         // 10.0
    float unk4;                         // 10.0
    float unk5;                         // 1.0
    byte padding2[8];
};

struct PostFXSettingsBlock(M3DOUBLEARRAY &array, int offs)
{
    FSeek(offs + array.offsetA);
    int timeOfDay[array.elements];
    FSeek(offs + array.offsetB);
    PostFXSettings settings[array.elements]<optimize=false>;
};

struct UnkColorSubBlock6
{
    RGBA colorA;
    RGBA colorB;
};

struct UnkColorBlock6(M3DOUBLEARRAY &array, int offs)
{
    FSeek(offs + array.offsetA);
    int timeOfDay[array.elements];
    FSeek(offs + array.offsetB);
    UnkColorSubBlock6 colorUnk[array.elements]<optimize=false>;;
};

struct UnkColorSubBlock7
{
    // Most probably wrong
    RGBA color0;

    unsigned byte unks0[8];
    float unk0;
    unsigned byte unks1[4];
    RGBA color1;
    float unk1;

    unsigned byte unks2[8];
    float unk2;
    unsigned byte unks3[4];
    RGBA color2;
    float unk3;

    unsigned byte unks4[8];
    float unk3;
    unsigned byte unks5[4];
    float unk4;
};


struct UnkColorBlock7(M3DOUBLEARRAY &array, int offs)
{
    FSeek(offs + array.offsetA);
    int unks[array.elements];
    FSeek(offs + array.offsetB);
    UnkColorSubBlock7 colorUnk[array.elements]<optimize=false>;;
};

struct DataBlock(sub_1407D0F30 &block)
{
    local int i;
    local int dataOffset;

    if (block.colorBlockArray.elements > 0)
    {
        // Array //
        FSeek(dOfs + block.colorBlockArray.offset);
        M3DOUBLEARRAY colorBlockArrays[block.colorBlockArray.elements];
        PAD16();
        
        // Data //
        dataOffset = FTell();
        for(i = 0; i < block.colorBlockArray.elements; i++)
        {
            ColorBlock colorBlock(colorBlockArrays[i], dataOffset);
        }
    }

    if (block.unk1.elements > 0)
    {
        // Array //
        FSeek(dOfs + block.unk1.offset);
        M3DOUBLEARRAY unks1[block.unk1.elements];
        PAD16();
    
        // Data //
        dataOffset = FTell();
        for(i = 0; i < block.unk1.elements; i++)
        {
            AngleAndColorBlock unkColorBlock(unks1[i], dataOffset);
        }
    }

    if (block.unk2.elements > 0)
    {
        // Array //
        FSeek(dOfs + block.unk2.offset);
        M3DOUBLEARRAY unks2[block.unk2.elements];
        PAD16();
    
        // Data //
        dataOffset = FTell();
        for(i = 0; i < block.unk2.elements; i++)
        {
            Gradient2Block fogColor(unks2[i], dataOffset);
        }
    }

    if (block.unk4.elements > 0)
    {
        // Array //
        FSeek(dOfs + block.unk4.offset);
        M3DOUBLEARRAY unks4[block.unk4.elements];
        PAD16();
    
        // Data //
        dataOffset = FTell();
        for(i = 0; i < block.unk4.elements; i++)
        {
            UnkColorBlock3 unkColorBlock(unks4[i], dataOffset);
        }
    }

    if (block.skySphereGradient.elements > 0)
    {
        // Data //
        FSeek(dOfs + block.skySphereGradient.offsetA);
        int timeOfDay[block.skySphereGradient.elements];
        FSeek(dOfs + block.skySphereGradient.offsetB);
        Gradient16 skySphereGradient[block.skySphereGradient.elements]<optimize=false>;
    }

    if (block.unk7.elements > 0)
    {
        // Array //
        FSeek(dOfs + block.unk7.offset);
        M3DOUBLEARRAY unks7[block.unk7.elements];
        PAD16();
    
        // Data //
        dataOffset = FTell();
        for(i = 0; i < block.unk7.elements; i++)
        {
            // tODO
            UnkColorBlock7 unkColorBlock(unks7[i], dataOffset);
        }
    }
    // TODO: missing Array/Data for unk3,unk5 (so far found only 0 array so ignored)
};

struct OffsetGroup
{
    // 48 bytes
    short unk0;
    short unk1;
    int padding;
    M3ARRAY arrayA;
    M3DOUBLEARRAY arrayB;
};

struct ModelInfo(OffsetGroup &ofsGrp, int dataStart)
{
    FSeek(dataStart + ofsGrp.arrayA.offset);
    wchar_t filePath[ofsGrp.arrayA.elements];

    AngleAndColorBlock colorBlock(ofsGrp.arrayB, dataStart);
};

struct SkyboxModels(M3ARRAY &modelInfoArray)
{
    FSeek(1216 + modelInfoArray.offset);
    
    OffsetGroup ofsGroups[modelInfoArray.elements];
    local int i;
    local int dataStart = FTell();
    for(i = 0; i < modelInfoArray.elements; i++)
    {
        ModelInfo modelInfo(ofsGroups[i], dataStart);
    }
};

struct Particulate(M3ARRAY &array)
{
    M3ARRAY particulateArrays[array.elements]<optimize=false>;
    local int dataStart = FTell();

    FSeek(dataStart + particulateArrays[0].offset);
    wchar_t particulatesModelPath[particulateArrays[0].elements];

    FSeek(dataStart + particulateArrays[1].offset);
    int unk;
};

struct UnkData
{
    int unks[14];
};

char magic[4];      // XSKY (verified in src)
int version;        // Has to be 16 (verified in src)
int unk0;           // 0,1
int unk1;           // 0,1
float unk2;          // 0.59988
int padding;
M3ARRAY sourceFileArray;
//FSeek(40);
sub_1407D0F30 dataBlockArray0;
//FSeek(192);
sub_1407D0F30 dataBlockArray1;
//FSeek(344);
sub_1407D0F30 dataBlockArray2;
//FSeek(496);
sub_1407D0F30 dataBlockArray3;
//FSeek(648);
M3DOUBLEARRAY sunLightColorArray;         // offs 648 sub_1407D7800
M3DOUBLEARRAY specularColorArray;         // offs 672 sub_1407D7770
M3DOUBLEARRAY unk5;         // offs 696 sub_1407D7800
M3DOUBLEARRAY fogSettingsArray;         // offs 720 sub_1407D7890
M3ARRAY modelInfoArray;     // offs 744 sub_1407D7920
M3DOUBLEARRAY postFXSettingsArray;         // offs 760 sub_1407D7A20
M3DOUBLEARRAY unk9;         // offs 784
M3DOUBLEARRAY unk10;        // offs 808
M3ARRAY particulateArray;   // offs 832
M3ARRAY envMapArray;        // offs 848
M3DOUBLEARRAY unk13;        // offs 864
M3ARRAY unk14;              // offs 880
M3ARRAY unk15;              // offs 896
M3ARRAY unk16;              // offs 912
M3ARRAY unk17;              // offs 928
M3DOUBLEARRAY unk18;        // offs 944 sub_1407D7800
M3DOUBLEARRAY unk19;        // offs 968 sub_1407D7800
M3ARRAY unk20;
M3DOUBLEARRAY unk21;        // offs 992 sub_1407D7770, reads this in a loop until m3 array is 0, only found 0 so far so ignoring
M3DOUBLEARRAY unk22;
FSeek(1184);                // Skip past the loop above, since it's just 0's
M3ARRAY unk23;              // offs 944 sub_1407D7AB0
M3ARRAY unk24;              // offs 944 ReadAString

// READ DATA //
FSeek(1216 + sourceFileArray.offset);
wchar_t sourcePath[sourceFileArray.elements];

DataBlock block(dataBlockArray0);
DataBlock block(dataBlockArray1);
DataBlock block(dataBlockArray2);
DataBlock block(dataBlockArray3);

ColorBlock sunLightColor(sunLightColorArray, dOfs);
AngleAndColorBlock specularColor(specularColorArray, dOfs);

// skipping unk5 found no data
if (fogSettingsArray.elements > 0)
    FogBlock fogSettings(fogSettingsArray, dOfs);

SkyboxModels models(modelInfoArray);

PostFXSettingsBlock postFX(postFXSettingsArray, dOfs);

if (unk9.elements > 0)
{
    FSeek(1216 + unk9.offsetA);
    int unkData0[8];
}

// skipping unk10 empty

Particulate particulates(particulateArray);

FSeek(1216 + envMapArray.offset);     // Environment cube map
wchar_t environmentMapPath[envMapArray.elements];

if (unk13.elements > 0)
    ColorBlock colorBlock3(unk13, dOfs);

FSeek(1216 + unk14.offset);
wchar_t sunGlareModelPathA[unk14.elements];

FSeek(1216 + unk15.offset);
wchar_t sunGlareModelPathB[unk15.elements];

// skipping unk16 empty
// skipping unk17 empty
// skipping unk18 empty
// skipping unk19 empty
// skipping unk20 empty

if (unk21.elements > 0)
{
    UnkColorBlock6 colorBlock4(unk21, dOfs);
}
if (unk22.elements > 0)
{
    UnkColorBlock6 colorBlock5(unk22, dOfs);
}
if (unk23.elements > 0)
{
    FSeek(1216 + unk23.offset);
    UnkData unkData1[unk23.elements];
}
if (unk24.elements > 0)
{
    FSeek(1216 + unk24.offset);
    wchar_t lutFile[unk24.elements];              // All 0's so far
}