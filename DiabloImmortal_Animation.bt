//------------------------------------------------
//      File: DiabloImmortal_Animation
//   Authors: Zee
//   Version: 1.0
//   Purpose: Reading animation data
//  Category: DiabloImmortal
//------------------------------------------------
#include "Lib/Common.bt"
#include "DiabloImmortal/AnimationKeyframe.bt"

struct Header
{
    FSeek(FileSize() - 88);

    int strLen;
    char HEADER[strLen];
    short padding;
    int dataSize;
    int empty0[4];

    int strLen;
    char CHANNEL_DATA[strLen];
    int unk;
    int empty1[4];

    int strLen;
    char MOTION_DATA[strLen];
    byte padding;
    int unk;

    FSeek(0);
};

struct Unk0x8Type
{
    char unk[14];
};

struct Unk0x8Type2
{
    char unk[16];
};

struct Track
{
    short keyframeCount;
    if (keyframeCount != 0)
    {
        byte compression;
    
        if (compression == 0)
        {
            byte unk;
            KeyframeVec3 keyframes[keyframeCount];
        }    
        else if (compression == 50)
        {
            Keyframe5B keyframes[keyframeCount]<optimize=false>;
        }
    }
};

struct Track2
{
    short keyframeCount;
    byte compression;
    byte unk;
    short unk;
    byte data[6];
};

typedef enum <byte>{ 
	hasScaleTrack = 0x01,
	hasPositionTrack = 0x02, 
	hasPositionTrackB = 0x04,
	unk0x8 = 0x08,
} ANIM_FLAGS <read=read_ANIM_FLAGS>;

string read_ANIM_FLAGS (local ANIM_FLAGS &af) {
	local string s = "";
	local ANIM_FLAGS i = 1;

	SPrintf (s, "%d: ", af);  

    
    s += IntToBinaryStr(af);
    s += " ";

    for( i = 0; i < 10; i++ )
	{
		if (af & i)
		{
			s = s + EnumToString(i);
            s = s + " ";
		}
	}
	return s;
}

struct BONE(ANIM_FLAGS &flags)
{
    byte nameLength;
    char name[nameLength];
    short parent;               // Bone parent

    local int t = 1;            // Rotation track always exists
    if (flags & 0x1) { t++; }
    if (flags & 0x2 || flags & 0x4) { t++; }

    local int i;
    for (i = 0; i < t; i++)
    {
        Track track;
        if (track.keyframeCount == 0 && i != t - 1)
        {
            short skip;     // Padding ?
        }
    }
};

struct BONE2(ANIM_FLAGS &flags)
{
    byte nameLength;
    char name[nameLength];
    uint parent;             // Bone parent

    local int i;
    Track2 track;
};

struct BONE_B
{
    byte nameLength;
    char name[nameLength];
    short parent;             // could be bone parent
};

struct BONEHIERARCHY
{
    short boneCount;
    BONE_B bone[boneCount]<optimize=false>;
};

//Header header;

// Test animation file format
char formatTest[4]<hidden=true>;
FSeek(0);

if (formatTest[0] == 78)
{
    // Header V1
    char magic[4];
    int chunkSize;
    int64 padding;
}
else
{
    // Header V2
    char magic[4];
}
char CHARANIM[10];
short someType;         // 2 or 3, if input parameter (animFormat == 4) { someType = 3; } else { someType = 2; }
short boneCount;        // total number of bones
short zero;
uint animationLength;   // animation length in miliseconds
byte animFormat;        // animation format: 0, 1, 2, 4
if (animFormat == 4)
{
    // Anim V1
    ANIM_FLAGS flags;       // if(inData + 17 != 0) then 1 |= 4 else 1
                            // if anim format is 4 then only 0x1 is ever set and probably doesn't mean scale, even though the game can also write 0x4 here
    time_t createTime;      // animation file creation time
    byte zero;              // always 0
    char a4;                // unknown parameter of AnimationCore::SerializeHeaderAndCharAnim()
    float a5;               // unknown parameter of AnimationCore::SerializeHeaderAndCharAnim()
    BONEHIERARCHY hierarchy;
    // bone data, NYI
    byte unk[53];
    int unk;
    int unk;
    int unk;
    int unk;
    float test[100];
}
else
{
    // Anim V2
    ANIM_FLAGS flags;       // |= 1, if (inData + 17 != 0) then |= 4, if (a5 >= 1) then |= 2
    time_t createTime;      // animation file creation time
    byte a5;                // parameter of AnimationCore::SerializeHeaderAndCharAnim()
    byte zero;              // = 0
    uint zero;              // = 0
    if (flags & 0x8)
    {
        Printf("Flag 0x8 not implemented bone type");
        // Only 40 animations have this, can ignore for now

        //BONE2 bone(flags)[boneCount]<optimize=false>;
    }
    else
    {
        BONE bone(flags)[boneCount]<optimize=false>;
    }
}