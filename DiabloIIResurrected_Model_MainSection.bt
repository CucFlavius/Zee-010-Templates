//--------------------------------------------------------------------------------------------------------------//
// Diablo 2 Resurrected Model Section
// D2R model section is the result of decompressing/processing/merging the sections in the original model file
// It's a required process so that the data can be parsed, granny sdk does this too (mostly the same as me)
// Could probably be parsed with just decompressing the sections, but the code would look like ass
// And it already does with all the jumping around in data
//--------------------------------------------------------------------------------------------------------------//

#include "Lib/Common.bt"

// Common

enum<uint> MemberType
{
    GrannyEndMember,
    GrannyInlineMember,
    GrannyReferenceMember,
    GrannyReferenceToArrayMember,
    GrannyArrayOfReferencesMember,
    GrannyVariantReferenceMember,
    GrannyUnsupportedMemberType_Remove,
    GrannyReferenceToVariantArrayMember,
    GrannyStringMember,
    GrannyTransformMember,
    GrannyReal32Member,
    GrannyInt8Member,
    GrannyUInt8Member,
    GrannyBinormalInt8Member,
    GrannyNormalUInt8Member,
    GrannyInt16Member,
    GrannyUInt16Member,
    GrannyBinormalInt16Member,
    GrannyNormalUInt16Member,
    GrannyInt32Member,
    GrannyUInt32Member,
    GrannyReal16Member,
    GrannyEmptyReferenceMember,
    GrannyOnePastLastMemberType,
    GrannyBool32Member = GrannyInt32Member,
    Grannymember_type_forceint = 0x7fffffff
};


struct Def
{
    MemberType Type;
    local string name = ReadStringPTR("Name");
    int64 ReferencePtr;            // Ref to the ptr of another DataTypeDefinition, not reading in case infinite recursive
    int ArrayWidth;
    int Extra[3];
    uint64 Ignored_Ignored;
};

struct DefinitionData(int64 ptrObj)
{
    int64 position;

    if (position != 0)
    {
        local long save = FTell();
        FSeek(position);
    
        local int i;
        local int counter = 0;
        for(i = 0; i < 1000; i++)
        {
            Def definition<hidden = true>;
            if (definition.Type == 0)
                break;
            counter = counter + 1;
        }

        FSeek(save);
        Def definitions[counter];

        FSeek(ptrObj);

        local string vName;

        for(i = 0; i < counter; i++)
        {
            //local long save2 = FTell();
            
            vName = definitions[i].name;

            switch (definitions[i].Type)
            {
                case 0:
Printf("GrannyInlineMember");
                    break;
                case 1:
                    int64 ReferenceMember;
                    break;
                case 1:
                    int32 ReferenceToArrayMember_Count;
                    int64 ReferenceToArrayMember_Offset;
                    break;
                case 2:
Printf("GrannyArrayOfReferencesMember");
                    break;
                case 3:
Printf("GrannyVariantReferenceMember");
                    break;
                case 4:
Printf("GrannyUnsupportedMemberType_Remove");
                    break;
                case 5:
Printf("GrannyReferenceToVariantArrayMember");
                    break;
                case 6:
                    ReadStringPTR("StringMember");
                    break;
                case 7:
Printf("GrannyTransformMember");
                    break;
                case 8:
                    float Real32Member;
                    break;
                case 9:
                    byte Int8Member;
                    break;
                case 10:
                    unsigned byte UInt8Member;
                    break;
                case 11:
Printf("GrannyBinormalInt8Member");
                    break;
                case 12:
Printf("GrannyNormalUInt8Member");
                    break;
                case 13:
                    int16 Int16Member;
                    break;
                case 14:
                    uint16 UInt16Member;
                    break;
                case 15:
Printf("GrannyBinormalInt16Member");
                    break;
                case 16:
Printf("GrannyNormalUInt16Member");
                    break;
                case 17:
                    int32 Int32Member;
                    break;
                case 18:
                    uint32 UInt32Member;
                    break;
                case 19:
Printf("GrannyReal16Member");
                    break;
                case 20:
Printf("GrannyEmptyReferenceMember");
                    break;
                case 21:
Printf("GrannyOnePastLastMemberType");
                    break;
                case 22:
Printf("Grannymember_type_forceint");
                    break;
                default:
Printf("UnkDefinitionType\n");
                    break;
            }
        }
        FSeek(save);
    }
};

struct DataTypeDefinition
{
    int64 position;

    if (position != 0)
    {
        local long save = FTell();
        FSeek(position);
    
        // Read until MemberType is EndMember, hard coding to read up to 100 just in case infinite loop
        local int i;
        for(i = 0; i < 100; i++)
        {
            Def definition;
            if (definition.Type == 0)
                break;
        }

        FSeek(save);
    }
};

typedef struct
{
    uint HasPosition : 1;
    uint HasOrientation : 1;
    uint HasScaleShear : 1;
    uint Forceint : 0x7fffffff;
} TransformFlags<size = 4>;

struct Transform
{
    TransformFlags Flags;
    VECTOR3 Position;
    QUATERNION Orientation;
    VECTOR3 ScaleShear[3];
};

typedef struct
{
    DataTypeDefinition type;
    int64 ptrObj;
}Extended<bgcolor = cBlack, fgcolor = 0x383838>;

typedef struct
{
    local long save = FTell();
    int64 skip<hidden=true>;
    int64 ptr<hidden=true>;
    FSeek(save);
    DefinitionData data(ptr);
    int64 ptrObj;

}ExtendedDATA<bgcolor = cPurple, fgcolor = cWhite>;


// Using this to jump to a string pointer, read the string, then go back to where I left off
string ReadStringPTR(char name[])
{
    int64 ptr<hidden=true>;
    local long savePos = FTell();
    FSeek(ptr);
    if (sizeof(name) > 0)
        STRINGn str(name);
    FSeek(savePos);

    return str.s;
}

// Art tool info

struct ArtToolInfo
{
    int64 position;
    local long save = FTell();
    FSeek(position);

    ReadStringPTR("FromArtToolName");
    int ArtToolMajorRevision;
    int ArtToolMinorRevision;
    int ArtToolPointerSize;
    float UnitsPerMeter;
    VECTOR3 Origin;
    VECTOR3 RightVector;
    VECTOR3 UpVector;
    VECTOR3 BackVector;
    Extended ExtendedData;

    FSeek(save);
};

// Exporter info

struct ExporterInfo
{
    int64 position;
    local long save = FTell();
    FSeek(position);

    ReadStringPTR("ExporterName");
    int ExporterMajorRevision;
    int ExporterMinorRevision;
    int ExporterCustomization;
    int ExporterBuildNumber;
    Extended ExtendedData;

    FSeek(save);
};

// Source file info

struct SourceFileInfo
{
    ReadStringPTR("SourceFile");
};

// Textures

struct PixelLayout
{
    int BytesPerPixel;
    int ShiftForComponent[4];
    int BitsForComponent[4];
};

struct Texture
{
    ReadStringPTR("FromFileName");
    int TextureType;
    int Width;
    int Height;
    int Encoding;
    int SubFormat;
    PixelLayout Layout;
    int ImageCount;
    int64 ptrTextureImage;      // TODO, or empty ?
    Extended ExtendedData;
};

struct Textures
{
    int textureCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if (textureCount > 0)
    {
        int64 texturePtrs[textureCount]<bgcolor=cYellow>;
        local int i;
        for (i = 0; i < textureCount; i++)
        {
            FSeek(texturePtrs[i]);
            Texture texture<optimize=false>;
        }
    }

    FSeek(save);
};

// Materials

typedef struct
{
    int caching;
    int frozen;
    int nodeState;
    int nodeState;
    float outColor[3];
    float outColorR;
    float outColorG;
    float outColorB;
    float outTransparency[3];
    float outTransparencyR;
    float outTransparencyG;
    float outTransparencyB;
    float outGlowColor[3];
    float outGlowColorR;
    float outGlowColorG;
    float outGlowColorB;
    float outMatteOpacity[3];
    float outMatteOpacityR;
    float outMatteOpacityG;
    float outMatteOpacityB;
    int enableHwShading;
    int varyingParametersCount;
    int64 varyingParametersOffset;
    int uniformParametersCount;
    int64 uniformParametersOffset;
    ReadStringPTR("Shader");
    ReadStringPTR("Effect Parameters");
    ReadStringPTR("Technique");
    ReadStringPTR("Description");
    ReadStringPTR("Diagnostics");
    ReadStringPTR("LightInfo");
    int isDoubleSided;
    int64 albedoTextureOffset;      // pointer to material that has reference to albedo texture
    float albedoTextureR;
    float albedoTextureG;
    float albedoTextureB;
    int64 normalTextureOffset;      // pointer to material that has reference to albedo texture
    float normalTextureR;
    float normalTextureG;
    float normalTextureB;
    int64 ormTextureOffset;      // pointer to material that has reference to albedo texture
    float ormTextureR;
    float ormTextureG;
    float ormTextureB;
    int64 PositionOffset;
    ReadStringPTR("Position_DefaultTexture");
    int64 NormalOffset;
    ReadStringPTR("Normal_DefaultTexture");
    int64 Color0Offset;
    ReadStringPTR("Color0_DefaultTexture");
    int64 TexCoord0Offset;
    ReadStringPTR("TexCoord0_DefaultTexture");
    int techniqueEnum;
    int techniqueEnum;
    float emissiveIntensity;
    ReadStringPTR("TypeName_DefaultTexture");
} ExtendedData_Shader<bgcolor=cWhite, fgcolor = cBlack>;

struct MaterialMap
{
    ReadStringPTR("Usage");
    int64 ptrMaterial;      // this points to existing material data
};

struct MaterialMaps (int count)
{
    int64 position;
    local long save = FTell();
    FSeek(position);

    if (count > 0)
    {
        MaterialMap materialMap[count]<optimize=false>;
    }
    FSeek(save);
};

struct Material
{
    ReadStringPTR("Name");
    int MapCount;
    MaterialMaps materialMaps(MapCount);
    int64 ptrTexture;       // this points to existing texture data
    Extended ExtendedData;

    // Read extended data (constant structure that blizz uses)
    local long save = FTell();
    FSeek(ExtendedData.ptrObj);
    if (ptrTexture == 0)        // if no texture it's an actual material
        ExtendedData_Shader shader;
    FSeek(save);
};


struct Materials
{
    int materialCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if (materialCount > 0)
    {
        int64 materialPtrs[materialCount]<bgcolor=cYellow>;
        local int i;
        for (i = 0; i < materialCount; i++)
        {
            FSeek(materialPtrs[i]);
            Material material<optimize=false>;
        }
    }

    FSeek(save);
};


// Skeletons

struct Bone
{
    ReadStringPTR("Name");
    int ParentIndex;
    Transform LocalTransform;
    MATRIX4x4 InverseWorld4x4;
    float LODError;
    Extended ExtendedData;
};

struct Bones (int count)
{
    int64 position;
    local long save = FTell();
    FSeek(position);

    if (count > 0)
    {
        Bone bone[count]<optimize=false>;
    }
    FSeek(save);
};

struct Skeleton
{
    ReadStringPTR("Name");
    int BoneCount;
    Bones bones(BoneCount);
    int LODType;
    Extended ExtendedData;
};

struct Skeletons
{
    int skeletonCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if (skeletonCount > 0)
    {
        int64 skeletonPtrs[skeletonCount]<bgcolor=cYellow>;
        local int i;
        for (i = 0; i < skeletonCount; i++)
        {
            FSeek(skeletonPtrs[i]);
            Skeleton skeleton<optimize=false>;
        }
    }

    FSeek(save);
};

// Vertex Data
struct Vertices
{
    int VertexCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    // This isn't really byte, it's a struct formed based on the data definitions in mesh,
    // well if the vertex data is read from mesh otherwise le shrug
    unsigned byte vertex[VertexCount]<optimize=false>;

    FSeek(save);
};

struct VertexComponentNames
{
    int VertexComponentNameCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    local int i;
    for (i = 0; i < VertexComponentNameCount; i++)
    {
        FSeek(skeletonPtrs[i]);
        ReadStringPTR("VertexComponentName");
        //Skeleton skeleton<optimize=false>;
    }

    FSeek(save);
};

struct VertexAnnotationSet
{
    ReadStringPTR("Name");
    DataTypeDefinition VertexAnnotationType;
    int VertexAnnotationCount;
    int64 ptrVertexAnnotations;                         // TODO
    int IndicesMapFromVertexToAnnotation;
    int VertexAnnotationIndexCount;
    int64 ptrVertexAnnotationIndices;                   // TODO
};

struct VertexAnnotationSets
{
    int VertexAnnotationSetCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if (VertexAnnotationSetCount > 0)
        VertexAnnotationSet set[VertexAnnotationSetCount];

    FSeek(save); 
};

struct VertexData
{
    DataTypeDefinition VertexType;
    Vertices vertices;
    VertexComponentNames vertexComponentNames;      // Unused ?
    VertexAnnotationSets vertexAnnotationSets;      // Unused ?
};

struct VertexDatas
{
    int vertexDatasCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if(vertexDatasCount > 0)
    {
        int64 vertexDataPtrs[vertexDatasCount]<bgcolor=cYellow>;
        local int i;
        for (i = 0; i < vertexDatasCount; i++)
        {
            FSeek(vertexDataPtrs[i]);
            VertexData vertexData<optimize=false>;
        }
    }
    FSeek(save);
};

// Triangle Topologies

struct Group
{
    int MaterialIndex;
    int TriFirst;
    int TriCount;
};

struct Groups (int count)
{
    int64 position;
    local long save = FTell();
    FSeek(position);

    if (count > 0)
    {
        Group group[count]<optimize=false>;
    }
    FSeek(save);
};

struct Int32s (int count)
{
    int64 position;
    local long save = FTell();
    FSeek(position);

    if (count > 0)
    {
        int index[count]<optimize=false>;
    }
    FSeek(save);
};

struct UInt32s (int count)
{
    int64 position;
    local long save = FTell();
    FSeek(position);

    if (count > 0)
    {
        uint index[count]<optimize=false>;
    }
    FSeek(save);
};

struct UInt16s (int count)
{
    int64 position;
    local long save = FTell();
    FSeek(position);

    if (count > 0)
    {
        ushort index[count]<optimize=false>;
    }
    FSeek(save);
};

struct TriAnnotationSet
{
    ReadStringPTR("Name");
    int64 ptrTriAnnotationType;             // TODO
    int TriAnnotationCount;
    int64 ptrTriAnnotations;                // TODO
    int IndicesMapFromTriToAnnotation;
    int TriAnnotationIndexCount;
    int64 ptrTriAnnotationIndices;          // TODO
};

struct TriAnnotationSets (int count)
{
    int64 position;
    local long save = FTell();
    FSeek(position);

    if (count > 0)
    {
        TriAnnotationSet set[count]<optimize=false>;
    }
    FSeek(save);
};

struct TriangleTopology
{
    int GroupCount;
    Groups groups(GroupCount);
    int IndexCount;
    Int32s indices(IndexCount);
    int Index16Count;
    UInt16s indices(Index16Count);
    int VertexToVertexCount;
    Int32s VertexToVertexMap(VertexToVertexCount);
    int VertexToTriangleCount;
    Int32s VertexToTriangleMap(VertexToTriangleCount);
    int SideToNeighborCount;
    UInt32s SideToNeighborMap(SideToNeighborCount);
    int PolygonIndexStartCount;
    Int32s PolygonIndexStarts(PolygonIndexStartCount);
    int PolygonIndexCount;
    Int32s PolygonIndices(PolygonIndexCount);
    int BonesForTriangleCount;
    Int32s BonesForTriangle(BonesForTriangleCount);
    int TriangleToBoneCount;
    Int32s ptrTriangleToBoneIndices(TriangleToBoneCount);
    int TriAnnotationSetCount;
    TriAnnotationSets triAnnotationSets(TriAnnotationSetCount);
};

struct TriangleTopologies
{
    int triangleToplogiesCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if(triangleToplogiesCount > 0)
    {
        int64 triangleTopologyPtrs[triangleToplogiesCount]<bgcolor=cYellow>;
        local int i;
        for (i = 0; i < triangleToplogiesCount; i++)
        {
            FSeek(triangleTopologyPtrs[i]);
            TriangleTopology triangleTopology<optimize=false>;
        }
    }
    FSeek(save);
};

// Meshes

struct MaterialBindings
{
    int MaterialBindingCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if(MaterialBindingCount > 0)
    {
        int64 materialBinding[MaterialBindingCount];    // Ref to existing data
    }
    
    FSeek(save);
};

struct BoneBinding
{
    ReadStringPTR("BoneName");
    VECTOR3 OBBMin;
    VECTOR3 OBBMax;
    int TriangleCount;          // Unused ??
    int64 ptrTriangleIndices;   // Unused ??
};

struct BoneBindings
{
    int BoneBindingCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if(BoneBindingCount > 0)
    {
        BoneBinding boneBinding[BoneBindingCount]<optimize=false>;    // Ref to existing data
    }
    
    FSeek(save);
};

struct Mesh
{
    ReadStringPTR("Name");
    int64 ptrPrimaryVertexData;
    local long save = FTell();
    FSeek(ptrPrimaryVertexData);
    VertexData primaryVertexData;
    FSeek(save);

    int MorphTargetCount;
    int64 ptrMorphTargets;          // TODO, unused?
    int64 ptrPrimaryTopology;       // Ref to existing data
    MaterialBindings materialBindings;
    BoneBindings boneBindings;
    Extended ExtendedData;
};

struct Meshes
{
    int meshesCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if(meshesCount > 0)
    {
        int64 meshPtrs[meshesCount]<bgcolor=cYellow>;
        local int i;
        for (i = 0; i < meshesCount; i++)
        {
            FSeek(meshPtrs[i]);
            Mesh mesh<optimize=false>;
        }
    }
    FSeek(save);
};

// Models

struct MeshBindings
{
    int MeshBindingCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if(MeshBindingCount > 0)
    {
        int64 meshBinding[MeshBindingCount];    // Ref to existing data
    }
    
    FSeek(save);
};


struct Model
{
    ReadStringPTR("Name");
    int64 ptrSkeleton;              // Ref to existing data
    Transform InitialPlacement;
    MeshBindings meshBindings;
    Extended ExtendedData;
};

struct Models
{
    int modelsCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if(modelsCount > 0)
    {
        int64 modelPtrs[modelsCount]<bgcolor=cYellow>;
        local int i;
        for (i = 0; i < modelsCount; i++)
        {
            FSeek(modelPtrs[i]);
            Model model<optimize=false>;
        }
    }
    FSeek(save);
};

// Track group


struct CurveDataHeader
{
    unsigned byte format;
    unsigned byte degree;
};

struct CurveDataHeader_DaIdentity
{
    CurveDataHeader header;
    short dimension;
};

struct CurveDataHeader_D3Constant32f
{
    CurveDataHeader header;
    short Padding;
    float Controls[3];
};

struct CurveDataHeader_D4Constant32f
{
    CurveDataHeader header;
    short padding;
    float Controls[4];
};

struct CurveDataHeader_DaConstant32f
{
    CurveDataHeader header;
    short padding;
    int controlCount;

    int64 controlOffset;
    local long save = FTell();
    FSeek(controlOffset);
    float Controls[controlCount];
    FSeek(save);
};

struct CurveDataHeader_D4nK16uC15u
{
    CurveDataHeader header;
    ushort ScaleOffsetTableEntries;
    float OneOverKnotScale;

    int KnotControlCount;
    int64 KnotControlOffset;
    local long save = FTell();
    FSeek(KnotControlOffset);
    uint16 KnotsControls[KnotControlCount];
    FSeek(save);
};

struct CurveDataHeader_D3I1K8uC8u
{
    CurveDataHeader header;
    ushort OneOverKnotScaleTrunc;
    float ControlScales[3];
    float ControlOffsets[3];

    int KnotControlCount;
    int64 KnotControlOffset;
    local long save = FTell();
    FSeek(KnotControlOffset);
    unsigned byte KnotsControls[KnotControlCount];
    FSeek(save);
};

struct CurveDataHeader_D4nK8uC7u
{
    CurveDataHeader header;
    ushort ScaleOffsetTableEntries;
    float OneOverKnotScale;

    int KnotControlCount;
    int64 KnotControlOffset;
    local long save = FTell();
    FSeek(KnotControlOffset);
    unsigned byte KnotsControls[KnotControlCount];
    FSeek(save);
};

struct CurveDataHeader_DaK16uC16u
{
    CurveDataHeader header;
    ushort OneOverKnotScaleTrunc;

    int ControlScaleOffsetCount;
    int64 ControlScaleOffsetOffset;
    local long save0 = FTell();
    FSeek(ControlScaleOffsetOffset);
    float ControlScaleOffsets[ControlScaleOffsetCount];
    FSeek(save0);

    int KnotControlCount;
    int64 KnotControlOffset;
    local long save1 = FTell();
    FSeek(KnotControlOffset);
    uint16 KnotsControls[KnotControlCount];
    FSeek(save1);
};

struct CurveDataHeader_DaK8uC8u
{
    CurveDataHeader header;
    ushort OneOverKnotScaleTrunc;

    int ControlScaleOffsetCount;
    int64 ControlScaleOffsetOffset;
    local long save0 = FTell();
    FSeek(ControlScaleOffsetOffset);
    float ControlScaleOffsets[ControlScaleOffsetCount];
    FSeek(save0);

    int KnotControlCount;
    int64 KnotControlOffset;
    local long save1 = FTell();
    FSeek(KnotControlOffset);
    unsigned byte KnotsControls[KnotControlCount];
    FSeek(save1);
};

struct CurveDataHeader_D3K8uC8u
{
    CurveDataHeader header;
    ushort OneOverKnotScaleTrunc;
    float ControlScales[3];
    float ControlOffsets[3];

    int KnotControlCount;
    int64 KnotControlOffset;
    local long save = FTell();
    FSeek(KnotControlOffset);
    unsigned byte KnotsControls[KnotControlCount];
    FSeek(save);
};

struct CurveDataHeader_D3K16uC16u
{
    CurveDataHeader header;
    ushort OneOverKnotScaleTrunc;
    float ControlScales[3];
    float ControlOffsets[3];

    int KnotControlCount;
    int64 KnotControlOffset;
    local long save = FTell();
    FSeek(KnotControlOffset);
    ushort KnotsControls[KnotControlCount];
    FSeek(save);
};

struct CurveDataHeader_DaK32fC32f
{
    CurveDataHeader header;
    short Padding;

    int KnotCount;
    int64 KnotOffset;
    local long save1 = FTell();
    FSeek(KnotOffset);
    float Knots[KnotCount];
    FSeek(save1);

    int ControlCount;
    int64 ControlOffset;
    local long save2 = FTell();
    FSeek(ControlOffset);
    float Controls[ControlCount];
    FSeek(save2);
};

struct Curve
{
    Extended curveDescription;

    local long save = FTell();
    FSeek(curveDescription.ptrObj);

    local string curveName = curveDescription.type.definition[0].name;

    if (curveName == "CurveDataHeader_DaIdentity")
        CurveDataHeader_DaIdentity curveData;
    else if (curveName == "CurveDataHeader_D3Constant32f")
        CurveDataHeader_D3Constant32f curveData;
    else if (curveName == "CurveDataHeader_D4Constant32f")
        CurveDataHeader_D4Constant32f curveData;
    else if (curveName == "CurveDataHeader_DaConstant32f")
        CurveDataHeader_DaConstant32f curveData;
    else if (curveName == "CurveDataHeader_D4nK16uC15u")
        CurveDataHeader_D4nK16uC15u curveData;
    else if (curveName == "CurveDataHeader_D3I1K8uC8u")
        CurveDataHeader_D3I1K8uC8u curveData;
    else if (curveName == "CurveDataHeader_D4nK8uC7u")
        CurveDataHeader_D4nK8uC7u curveData;
    else if (curveName == "CurveDataHeader_DaK16uC16u")
        CurveDataHeader_DaK16uC16u curveData;
    else if (curveName == "CurveDataHeader_DaK8uC8u")
        CurveDataHeader_DaK8uC8u curveData;
    else if (curveName == "CurveDataHeader_D3K8uC8u")
        CurveDataHeader_D3K8uC8u curveData;
    else if (curveName == "CurveDataHeader_D3K16uC16u")
        CurveDataHeader_D3K16uC16u curveData;
    else if (curveName == "CurveDataHeader_DaK32fC32f")
        CurveDataHeader_DaK32fC32f curveData;
    else
        Printf(curveName + "\n");
    // so on and so forth

    FSeek(save);
};

struct VectorTrack
{
    ReadStringPTR("Name");
    uint trackKey;
    int dimension;
    Curve curve;
};

struct VectorTracks
{
    int VectorTrackCount;
    int64 ptrVectorTracks;

    local long save = FTell();
    FSeek(ptrVectorTracks);

    if (VectorTrackCount > 0)
        VectorTrack track[VectorTrackCount]<optimize=false>;

    FSeek(save);
};

struct TransformTrack
{
    local string name = ReadStringPTR("Name");
    int flags;
    Curve orientationCurve;
    Curve positionCurve;
    Curve scaleShearCurve;
};

struct TransformTracks
{
    int TransformTrackCount;
    int64 ptrTransformTracks;

    local long save = FTell();
    FSeek(ptrTransformTracks);

    if (TransformTrackCount > 0)
    {
        TransformTrack track[TransformTrackCount]<optimize=false>;
    
        local int i;
        for(i = 0; i < TransformTrackCount; i++)
        {
            if (track[i].orientationCurve.curveDescription.type.definition[0].name == "CurveDataHeader_DaK32fC32f")
                Printf( "Num = %d, Str = '%s'\n", i, track[i].name );
        }
    }

    FSeek(save);
};

struct TrackGroup
{
    ReadStringPTR("Name");
    VectorTracks vectorTracks;
    TransformTracks transformTracks;
    int TransformLODErrorCount;
    int64 ptrTransformLODErrors;    // TODO
    int TextTrackCount;
    int64 ptrTextTracks;            // TODO
    Transform InitialPlacement;
    int Flags;
    VECTOR3 LoopTranslation;
    int64 ptrPeriodicLoop;          // TODO
    Extended ExtendedData;
};

struct TrackGroups
{
    int trackGroupsCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if(trackGroupsCount > 0)
    {
        int64 trackGroupPtrs[trackGroupsCount]<bgcolor=cYellow>;
        local int i;
        for (i = 0; i < trackGroupsCount; i++)
        {
            FSeek(trackGroupPtrs[i]);
            TrackGroup trackGroup<optimize=false>;
        }
    }
    FSeek(save);
};

// Animation
struct Animation
{
    local string name = ReadStringPTR("Name");
    float Duration;
    float TimeStep;
    float Oversampling;
    TrackGroups tracks;
    int DefaultLoopCount;
    int Flags;
    Extended ExtendedData;
};

struct Animations
{
    int animationsCount;
    int64 position;
    local long save = FTell();
    FSeek(position);

    if(animationsCount > 0)
    {
        int64 animationPtrs[animationsCount]<bgcolor=cYellow>;
        local int i;
        for (i = 0; i < animationsCount; i++)
        {
            FSeek(animationPtrs[i]);
            Animation animation<optimize=false>;

            Printf( "Animation [%d], Name = '%s'\n", i, animation.name );
        }
    }
    FSeek(save);
};


// Read File //

ArtToolInfo artToolInfo<bgcolor=cBlue>;
ExporterInfo exporterInfo<bgcolor=cLtPurple>;
SourceFileInfo sourceFileInfo<bgcolor=0x32a8a6>;
Textures textures<bgcolor=cLtGreen>;
Materials materials<bgcolor=cRed>;
Skeletons skeletons<bgcolor=0xc56bc7>;
VertexDatas vertexDatas<bgcolor=0x53bfe0>;
TriangleTopologies triangleTopologies<bgcolor=cLtRed>;
Meshes meshes<bgcolor=0x07a321>;
Models models<bgcolor=cPurple>;
TrackGroups trackGroups<bgcolor=cGreen>;
Animations animations<bgcolor=cLtBlue>;
Extended ExtendedData;
